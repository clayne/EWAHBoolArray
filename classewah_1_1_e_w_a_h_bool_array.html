<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EWAHBoolArray: ewah::EWAHBoolArray&lt; uword &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">EWAHBoolArray<span id="projectnumber">&#160;0.8.0</span>
   </div>
   <div id="projectbrief">A compressed bitmap class in C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classewah_1_1_e_w_a_h_bool_array.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classewah_1_1_e_w_a_h_bool_array-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ewah::EWAHBoolArray&lt; uword &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This class is a compressed bitmap.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ewah_8h_source.html">ewah.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a808a462b897cc280f4b8027b0008bfe1" id="r_a808a462b897cc280f4b8027b0008bfe1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>RESERVEMEMORY</b> = true
 }</td></tr>
<tr class="separator:a808a462b897cc280f4b8027b0008bfe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ab033778d1b59295cc60e2dd6d2a46" id="r_ac6ab033778d1b59295cc60e2dd6d2a46"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>wordinbits</b> = sizeof(uword) * 8
 }</td></tr>
<tr class="separator:ac6ab033778d1b59295cc60e2dd6d2a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84788ea33e8536ab81762d24b8e1a886" id="r_a84788ea33e8536ab81762d24b8e1a886"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classewah_1_1_e_w_a_h_bool_array_set_bit_forward_iterator.html">EWAHBoolArraySetBitForwardIterator</a>&lt; uword &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84788ea33e8536ab81762d24b8e1a886">const_iterator</a></td></tr>
<tr class="separator:a84788ea33e8536ab81762d24b8e1a886"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae2e27b9636665da8a1db214d30bb0b23" id="r_ae2e27b9636665da8a1db214d30bb0b23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2e27b9636665da8a1db214d30bb0b23">trim</a> ()</td></tr>
<tr class="memdesc:ae2e27b9636665da8a1db214d30bb0b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recover wasted memory usage.  <br /></td></tr>
<tr class="separator:ae2e27b9636665da8a1db214d30bb0b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48045ede9ca6065b8c7b7f7f8e9a0260" id="r_a48045ede9ca6065b8c7b7f7f8e9a0260"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48045ede9ca6065b8c7b7f7f8e9a0260">get</a> (const size_t pos) const</td></tr>
<tr class="memdesc:a48045ede9ca6065b8c7b7f7f8e9a0260"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the value of bit i.  <br /></td></tr>
<tr class="separator:a48045ede9ca6065b8c7b7f7f8e9a0260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee92b036e93865f09414d67417a26f2" id="r_aaee92b036e93865f09414d67417a26f2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaee92b036e93865f09414d67417a26f2">empty</a> () const</td></tr>
<tr class="memdesc:aaee92b036e93865f09414d67417a26f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if no bit is set.  <br /></td></tr>
<tr class="separator:aaee92b036e93865f09414d67417a26f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c5d9990d6efccf50fcacb766ee45169" id="r_a7c5d9990d6efccf50fcacb766ee45169"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c5d9990d6efccf50fcacb766ee45169">set</a> (size_t i)</td></tr>
<tr class="memdesc:a7c5d9990d6efccf50fcacb766ee45169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the ith bit to true (starting at zero).  <br /></td></tr>
<tr class="separator:a7c5d9990d6efccf50fcacb766ee45169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a3f4f66dab5e9e55e309621b769b99" id="r_ac7a3f4f66dab5e9e55e309621b769b99"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7a3f4f66dab5e9e55e309621b769b99">operator std::string</a> () const</td></tr>
<tr class="memdesc:ac7a3f4f66dab5e9e55e309621b769b99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform into a string that presents a list of set bits.  <br /></td></tr>
<tr class="separator:ac7a3f4f66dab5e9e55e309621b769b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a5e399a845e3a991bd9d33db6fa40e0" id="r_a1a5e399a845e3a991bd9d33db6fa40e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a5e399a845e3a991bd9d33db6fa40e0">makeSameSize</a> (<a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a> &amp;a)</td></tr>
<tr class="memdesc:a1a5e399a845e3a991bd9d33db6fa40e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make sure the two bitmaps have the same size (padding with zeroes if necessary).  <br /></td></tr>
<tr class="separator:a1a5e399a845e3a991bd9d33db6fa40e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb78ae6e98b0668facae5b40387a6ce" id="r_a7fb78ae6e98b0668facae5b40387a6ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classewah_1_1_e_w_a_h_bool_array_set_bit_forward_iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7fb78ae6e98b0668facae5b40387a6ce">begin</a> () const</td></tr>
<tr class="memdesc:a7fb78ae6e98b0668facae5b40387a6ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator that can be used to access the position of the set bits.  <br /></td></tr>
<tr class="separator:a7fb78ae6e98b0668facae5b40387a6ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac22911991183267851a7c948433d392d" id="r_ac22911991183267851a7c948433d392d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classewah_1_1_e_w_a_h_bool_array_set_bit_forward_iterator.html">const_iterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac22911991183267851a7c948433d392d">end</a> () const</td></tr>
<tr class="memdesc:ac22911991183267851a7c948433d392d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basically a bogus iterator that can be used together with <a class="el" href="#a7fb78ae6e98b0668facae5b40387a6ce" title="Returns an iterator that can be used to access the position of the set bits.">begin()</a> for constructions such as for(EWAHBoolArray&lt;uword&gt;::iterator i = b.begin(); i!=b.end(); ++i) {}.  <br /></td></tr>
<tr class="separator:ac22911991183267851a7c948433d392d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb8c572192eb6e11da029d76a0066b5" id="r_aecb8c572192eb6e11da029d76a0066b5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aecb8c572192eb6e11da029d76a0066b5">toArray</a> () const</td></tr>
<tr class="memdesc:aecb8c572192eb6e11da029d76a0066b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the set bits.  <br /></td></tr>
<tr class="separator:aecb8c572192eb6e11da029d76a0066b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2bbba4a8293ba6f778dff81b7e8c1ae" id="r_ab2bbba4a8293ba6f778dff81b7e8c1ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2bbba4a8293ba6f778dff81b7e8c1ae">logicaland</a> (const <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a> &amp;a, <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a> &amp;container) const</td></tr>
<tr class="memdesc:ab2bbba4a8293ba6f778dff81b7e8c1ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the logical and with another compressed bitmap answer goes into container Running time complexity is proportional to the sum of the compressed bitmap sizes.  <br /></td></tr>
<tr class="separator:ab2bbba4a8293ba6f778dff81b7e8c1ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b615ad43a09d293dd3c27a307c56396" id="r_a6b615ad43a09d293dd3c27a307c56396"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b615ad43a09d293dd3c27a307c56396">logicaland</a> (const <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a> &amp;a) const</td></tr>
<tr class="memdesc:a6b615ad43a09d293dd3c27a307c56396"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the logical and with another compressed bitmap Return the answer Running time complexity is proportional to the sum of the compressed bitmap sizes.  <br /></td></tr>
<tr class="separator:a6b615ad43a09d293dd3c27a307c56396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1521faaf0da44fd6af2fbc8672e7a96" id="r_ac1521faaf0da44fd6af2fbc8672e7a96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1521faaf0da44fd6af2fbc8672e7a96">operator&amp;</a> (const <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a> &amp;a) const</td></tr>
<tr class="memdesc:ac1521faaf0da44fd6af2fbc8672e7a96"><td class="mdescLeft">&#160;</td><td class="mdescRight">calls logicaland  <br /></td></tr>
<tr class="separator:ac1521faaf0da44fd6af2fbc8672e7a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c960408fd986b621df413dbb0ee652" id="r_a39c960408fd986b621df413dbb0ee652"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39c960408fd986b621df413dbb0ee652">logicalandnot</a> (const <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a> &amp;a, <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a> &amp;container) const</td></tr>
<tr class="memdesc:a39c960408fd986b621df413dbb0ee652"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the logical and with another compressed bitmap answer goes into container Running time complexity is proportional to the sum of the compressed bitmap sizes.  <br /></td></tr>
<tr class="separator:a39c960408fd986b621df413dbb0ee652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28ad4e6e2045b292600d3cb0dcc1fab5" id="r_a28ad4e6e2045b292600d3cb0dcc1fab5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28ad4e6e2045b292600d3cb0dcc1fab5">operator-</a> (const <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a> &amp;a) const</td></tr>
<tr class="memdesc:a28ad4e6e2045b292600d3cb0dcc1fab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">calls logicalandnot  <br /></td></tr>
<tr class="separator:a28ad4e6e2045b292600d3cb0dcc1fab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35920c8869a091b08e2d18c74af43d7c" id="r_a35920c8869a091b08e2d18c74af43d7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a35920c8869a091b08e2d18c74af43d7c">logicalandnot</a> (const <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a> &amp;a) const</td></tr>
<tr class="memdesc:a35920c8869a091b08e2d18c74af43d7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the logical and not with another compressed bitmap Return the answer Running time complexity is proportional to the sum of the compressed bitmap sizes.  <br /></td></tr>
<tr class="separator:a35920c8869a091b08e2d18c74af43d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae251a6683ce14932c4bbe450ea4929ba" id="r_ae251a6683ce14932c4bbe450ea4929ba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae251a6683ce14932c4bbe450ea4929ba">intersects</a> (const <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a> &amp;a) const</td></tr>
<tr class="memdesc:ae251a6683ce14932c4bbe450ea4929ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests whether the bitmaps "intersect" (have at least one 1-bit at the same position).  <br /></td></tr>
<tr class="separator:ae251a6683ce14932c4bbe450ea4929ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a248b3b85d65973b31b097339cf7e6598" id="r_a248b3b85d65973b31b097339cf7e6598"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a248b3b85d65973b31b097339cf7e6598">logicalor</a> (const <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a> &amp;a, <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a> &amp;container) const</td></tr>
<tr class="memdesc:a248b3b85d65973b31b097339cf7e6598"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the logical or with another compressed bitmap answer goes into container Running time complexity is proportional to the sum of the compressed bitmap sizes.  <br /></td></tr>
<tr class="separator:a248b3b85d65973b31b097339cf7e6598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf41e834801112e7e109c7faa9c95539" id="r_aaf41e834801112e7e109c7faa9c95539"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf41e834801112e7e109c7faa9c95539">logicalorcount</a> (const <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a> &amp;a) const</td></tr>
<tr class="memdesc:aaf41e834801112e7e109c7faa9c95539"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the size (in number of set bits) of the logical or with another compressed bitmap Running time complexity is proportional to the sum of the compressed bitmap sizes.  <br /></td></tr>
<tr class="separator:aaf41e834801112e7e109c7faa9c95539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a426745653634283858eb7202a708078c" id="r_a426745653634283858eb7202a708078c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a426745653634283858eb7202a708078c">logicalandcount</a> (const <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a> &amp;a) const</td></tr>
<tr class="memdesc:a426745653634283858eb7202a708078c"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the size (in number of set bits) of the logical and with another compressed bitmap Running time complexity is proportional to the sum of the compressed bitmap sizes.  <br /></td></tr>
<tr class="separator:a426745653634283858eb7202a708078c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac1ae1bd3065afae9dd6c5d4717636da" id="r_aac1ae1bd3065afae9dd6c5d4717636da"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac1ae1bd3065afae9dd6c5d4717636da">logicalandnotcount</a> (const <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a> &amp;a) const</td></tr>
<tr class="memdesc:aac1ae1bd3065afae9dd6c5d4717636da"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the size (in number of set bits) of the logical and not with another compressed bitmap Running time complexity is proportional to the sum of the compressed bitmap sizes.  <br /></td></tr>
<tr class="separator:aac1ae1bd3065afae9dd6c5d4717636da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa71f3e9a634b503b1842b161d46d41ea" id="r_aa71f3e9a634b503b1842b161d46d41ea"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa71f3e9a634b503b1842b161d46d41ea">logicalxorcount</a> (const <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a> &amp;a) const</td></tr>
<tr class="memdesc:aa71f3e9a634b503b1842b161d46d41ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the size (in number of set bits) of the logical xor with another compressed bitmap Running time complexity is proportional to the sum of the compressed bitmap sizes.  <br /></td></tr>
<tr class="separator:aa71f3e9a634b503b1842b161d46d41ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aee1e8a6225d49a1e65eb22befbed0a" id="r_a0aee1e8a6225d49a1e65eb22befbed0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0aee1e8a6225d49a1e65eb22befbed0a">logicalor</a> (const <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a> &amp;a) const</td></tr>
<tr class="memdesc:a0aee1e8a6225d49a1e65eb22befbed0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the logical or with another compressed bitmap Return the answer Running time complexity is proportional to the sum of the compressed bitmap sizes.  <br /></td></tr>
<tr class="separator:a0aee1e8a6225d49a1e65eb22befbed0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a131166e4df8e01c5f66a3eb52cc685" id="r_a4a131166e4df8e01c5f66a3eb52cc685"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a131166e4df8e01c5f66a3eb52cc685">operator|</a> (const <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a> &amp;a) const</td></tr>
<tr class="memdesc:a4a131166e4df8e01c5f66a3eb52cc685"><td class="mdescLeft">&#160;</td><td class="mdescRight">calls logicalor  <br /></td></tr>
<tr class="separator:a4a131166e4df8e01c5f66a3eb52cc685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0effb2623cb241062ffad9f26a5601e5" id="r_a0effb2623cb241062ffad9f26a5601e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0effb2623cb241062ffad9f26a5601e5">logicalxor</a> (const <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a> &amp;a, <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a> &amp;container) const</td></tr>
<tr class="memdesc:a0effb2623cb241062ffad9f26a5601e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the logical xor with another compressed bitmap answer goes into container Running time complexity is proportional to the sum of the compressed bitmap sizes.  <br /></td></tr>
<tr class="separator:a0effb2623cb241062ffad9f26a5601e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94e407bdfd92cc38ea4d5929177e9ee1" id="r_a94e407bdfd92cc38ea4d5929177e9ee1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94e407bdfd92cc38ea4d5929177e9ee1">logicalxor</a> (const <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a> &amp;a) const</td></tr>
<tr class="memdesc:a94e407bdfd92cc38ea4d5929177e9ee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the logical xor with another compressed bitmap Return the answer Running time complexity is proportional to the sum of the compressed bitmap sizes.  <br /></td></tr>
<tr class="separator:a94e407bdfd92cc38ea4d5929177e9ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a357e1917ef3ec396fde72c54d523feaf" id="r_a357e1917ef3ec396fde72c54d523feaf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a357e1917ef3ec396fde72c54d523feaf">operator^</a> (const <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a> &amp;a) const</td></tr>
<tr class="memdesc:a357e1917ef3ec396fde72c54d523feaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">calls logicalxor  <br /></td></tr>
<tr class="separator:a357e1917ef3ec396fde72c54d523feaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad172a0052454ec59aafd2140df69c398" id="r_ad172a0052454ec59aafd2140df69c398"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad172a0052454ec59aafd2140df69c398">reset</a> ()</td></tr>
<tr class="memdesc:ad172a0052454ec59aafd2140df69c398"><td class="mdescLeft">&#160;</td><td class="mdescRight">clear the content of the bitmap.  <br /></td></tr>
<tr class="separator:ad172a0052454ec59aafd2140df69c398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9969a7dccfe1c42288ec4790cc27ee8a" id="r_a9969a7dccfe1c42288ec4790cc27ee8a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9969a7dccfe1c42288ec4790cc27ee8a">addWord</a> (const uword newdata, const uint32_t bitsthatmatter=8 *sizeof(uword))</td></tr>
<tr class="memdesc:a9969a7dccfe1c42288ec4790cc27ee8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience method.  <br /></td></tr>
<tr class="separator:a9969a7dccfe1c42288ec4790cc27ee8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad431d2437ba346f2d65ceee781364ab4" id="r_ad431d2437ba346f2d65ceee781364ab4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad431d2437ba346f2d65ceee781364ab4">printout</a> (std::ostream &amp;o=std::cout)</td></tr>
<tr class="separator:ad431d2437ba346f2d65ceee781364ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a627a015ab2f8837f15d0b1bf15b2c9bc" id="r_a627a015ab2f8837f15d0b1bf15b2c9bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a627a015ab2f8837f15d0b1bf15b2c9bc">debugprintout</a> () const</td></tr>
<tr class="memdesc:a627a015ab2f8837f15d0b1bf15b2c9bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a verbose description of the content of the compressed bitmap.  <br /></td></tr>
<tr class="separator:a627a015ab2f8837f15d0b1bf15b2c9bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba5c323355b42ad471317ff17fdd2b60" id="r_aba5c323355b42ad471317ff17fdd2b60"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba5c323355b42ad471317ff17fdd2b60">sizeInBits</a> () const</td></tr>
<tr class="memdesc:aba5c323355b42ad471317ff17fdd2b60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size in bits of this bitmap (this refers to the uncompressed size in bits).  <br /></td></tr>
<tr class="separator:aba5c323355b42ad471317ff17fdd2b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cdac35befecda0dd94b804248b474f4" id="r_a3cdac35befecda0dd94b804248b474f4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3cdac35befecda0dd94b804248b474f4">sizeInBytes</a> () const</td></tr>
<tr class="memdesc:a3cdac35befecda0dd94b804248b474f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size of the buffer in bytes.  <br /></td></tr>
<tr class="separator:a3cdac35befecda0dd94b804248b474f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b035800d9987fe09ecbfd7571daa4c" id="r_a99b035800d9987fe09ecbfd7571daa4c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a99b035800d9987fe09ecbfd7571daa4c">addStreamOfEmptyWords</a> (const bool v, size_t number)</td></tr>
<tr class="memdesc:a99b035800d9987fe09ecbfd7571daa4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">same as addEmptyWord, but you can do several in one shot! returns the number of words added (storage cost increase)  <br /></td></tr>
<tr class="separator:a99b035800d9987fe09ecbfd7571daa4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a27432d57daa8d60a8a54256140fc0" id="r_ad3a27432d57daa8d60a8a54256140fc0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3a27432d57daa8d60a8a54256140fc0">addStreamOfDirtyWords</a> (const uword *v, const size_t number)</td></tr>
<tr class="memdesc:ad3a27432d57daa8d60a8a54256140fc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a stream of dirty words, returns the number of words added (storage cost increase)  <br /></td></tr>
<tr class="separator:ad3a27432d57daa8d60a8a54256140fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f6242bbe7f1faf71c03cef84796e281" id="r_a3f6242bbe7f1faf71c03cef84796e281"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f6242bbe7f1faf71c03cef84796e281">addStreamOfNegatedDirtyWords</a> (const uword *v, const size_t number)</td></tr>
<tr class="memdesc:a3f6242bbe7f1faf71c03cef84796e281"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a stream of dirty words, each one negated, returns the number of words added (storage cost increase)  <br /></td></tr>
<tr class="separator:a3f6242bbe7f1faf71c03cef84796e281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2436a4ea098bdab8cf7db4d2cdceaa16" id="r_a2436a4ea098bdab8cf7db4d2cdceaa16"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2436a4ea098bdab8cf7db4d2cdceaa16">padWithZeroes</a> (const size_t totalbits)</td></tr>
<tr class="memdesc:a2436a4ea098bdab8cf7db4d2cdceaa16"><td class="mdescLeft">&#160;</td><td class="mdescRight">make sure the size of the array is totalbits bits by padding with zeroes.  <br /></td></tr>
<tr class="separator:a2436a4ea098bdab8cf7db4d2cdceaa16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8f3e7d0bfbb32c44e548926897d5f8d" id="r_ab8f3e7d0bfbb32c44e548926897d5f8d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8f3e7d0bfbb32c44e548926897d5f8d">sizeOnDisk</a> (const bool savesizeinbits=true) const</td></tr>
<tr class="memdesc:ab8f3e7d0bfbb32c44e548926897d5f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the size on disk assuming that it was saved using the method "write".  <br /></td></tr>
<tr class="separator:ab8f3e7d0bfbb32c44e548926897d5f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab230c3b69a4ab6d45ab324e60d34600e" id="r_ab230c3b69a4ab6d45ab324e60d34600e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab230c3b69a4ab6d45ab324e60d34600e">write</a> (std::ostream &amp;out, const bool savesizeinbits=true) const</td></tr>
<tr class="memdesc:ab230c3b69a4ab6d45ab324e60d34600e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save this bitmap to a stream.  <br /></td></tr>
<tr class="separator:ab230c3b69a4ab6d45ab324e60d34600e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2544580dbbf767740398205138b331b0" id="r_a2544580dbbf767740398205138b331b0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2544580dbbf767740398205138b331b0">write</a> (char *out, size_t capacity, const bool savesizeinbits=true) const</td></tr>
<tr class="memdesc:a2544580dbbf767740398205138b331b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">same as write(std::ostream...), except that you provide a char pointer and a "capacity" (in bytes).  <br /></td></tr>
<tr class="separator:a2544580dbbf767740398205138b331b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabae9f0dcc0048b70ff4e9e397bacf4c" id="r_aabae9f0dcc0048b70ff4e9e397bacf4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aabae9f0dcc0048b70ff4e9e397bacf4c">writeBuffer</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:aabae9f0dcc0048b70ff4e9e397bacf4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This only writes the content of the buffer (see <a class="el" href="#ab230c3b69a4ab6d45ab324e60d34600e" title="Save this bitmap to a stream.">write()</a>) method.  <br /></td></tr>
<tr class="separator:aabae9f0dcc0048b70ff4e9e397bacf4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a481f8a644db093edc1fbf85f2c07fbf3" id="r_a481f8a644db093edc1fbf85f2c07fbf3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a481f8a644db093edc1fbf85f2c07fbf3">bufferSize</a> () const</td></tr>
<tr class="memdesc:a481f8a644db093edc1fbf85f2c07fbf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">size (in words) of the underlying STL vector.  <br /></td></tr>
<tr class="separator:a481f8a644db093edc1fbf85f2c07fbf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab28a0765db41edf55399c9e883bf1130" id="r_ab28a0765db41edf55399c9e883bf1130"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab28a0765db41edf55399c9e883bf1130">read</a> (std::istream &amp;in, const bool savesizeinbits=true)</td></tr>
<tr class="memdesc:ab28a0765db41edf55399c9e883bf1130"><td class="mdescLeft">&#160;</td><td class="mdescRight">this is the counterpart to the write method.  <br /></td></tr>
<tr class="separator:ab28a0765db41edf55399c9e883bf1130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf6fe7cb001de949c6254d61bdaa28bc" id="r_adf6fe7cb001de949c6254d61bdaa28bc"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf6fe7cb001de949c6254d61bdaa28bc">read</a> (const char *in, size_t capacity, const bool savesizeinbits=true)</td></tr>
<tr class="memdesc:adf6fe7cb001de949c6254d61bdaa28bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">same as read(std::istream...), except that you provide a char pointer and a "capacity" (in bytes).  <br /></td></tr>
<tr class="separator:adf6fe7cb001de949c6254d61bdaa28bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6b066f3fe7b02b18e3505ace63ad1ed" id="r_aa6b066f3fe7b02b18e3505ace63ad1ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6b066f3fe7b02b18e3505ace63ad1ed">readBuffer</a> (std::istream &amp;in, const size_t buffersize)</td></tr>
<tr class="memdesc:aa6b066f3fe7b02b18e3505ace63ad1ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">read the buffer from a stream, see method writeBuffer.  <br /></td></tr>
<tr class="separator:aa6b066f3fe7b02b18e3505ace63ad1ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a016138a6037ff061b17e931be4ab9d48" id="r_a016138a6037ff061b17e931be4ab9d48"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a016138a6037ff061b17e931be4ab9d48">operator==</a> (const <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a> &amp;x) const</td></tr>
<tr class="memdesc:a016138a6037ff061b17e931be4ab9d48"><td class="mdescLeft">&#160;</td><td class="mdescRight">We define two <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html" title="This class is a compressed bitmap.">EWAHBoolArray</a> as being equal if they have the same set bits.  <br /></td></tr>
<tr class="separator:a016138a6037ff061b17e931be4ab9d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2a77cb0c3ae12baa53894a3ac01ea11" id="r_ad2a77cb0c3ae12baa53894a3ac01ea11"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2a77cb0c3ae12baa53894a3ac01ea11">operator!=</a> (const <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a> &amp;x) const</td></tr>
<tr class="memdesc:ad2a77cb0c3ae12baa53894a3ac01ea11"><td class="mdescLeft">&#160;</td><td class="mdescRight">We define two <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html" title="This class is a compressed bitmap.">EWAHBoolArray</a> as being different if they do not have the same set bits.  <br /></td></tr>
<tr class="separator:ad2a77cb0c3ae12baa53894a3ac01ea11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacbaff6cc426f05ad72cab4e591e919d" id="r_aacbaff6cc426f05ad72cab4e591e919d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aacbaff6cc426f05ad72cab4e591e919d">operator==</a> (const <a class="el" href="classewah_1_1_bool_array.html">BoolArray</a>&lt; uword &gt; &amp;x) const</td></tr>
<tr class="separator:aacbaff6cc426f05ad72cab4e591e919d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af31f1d4b93490905c0892a74e46216c9" id="r_af31f1d4b93490905c0892a74e46216c9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af31f1d4b93490905c0892a74e46216c9">operator!=</a> (const <a class="el" href="classewah_1_1_bool_array.html">BoolArray</a>&lt; uword &gt; &amp;x) const</td></tr>
<tr class="separator:af31f1d4b93490905c0892a74e46216c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff6e5f23f9bd6dd826de4295fd92dcd4" id="r_aff6e5f23f9bd6dd826de4295fd92dcd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classewah_1_1_e_w_a_h_bool_array_iterator.html">EWAHBoolArrayIterator</a>&lt; uword &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff6e5f23f9bd6dd826de4295fd92dcd4">uncompress</a> () const</td></tr>
<tr class="memdesc:aff6e5f23f9bd6dd826de4295fd92dcd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over the uncompressed words.  <br /></td></tr>
<tr class="separator:aff6e5f23f9bd6dd826de4295fd92dcd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12016e63b2cfe63f73584c7abc4edd2a" id="r_a12016e63b2cfe63f73584c7abc4edd2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classewah_1_1_e_w_a_h_bool_array_raw_iterator.html">EWAHBoolArrayRawIterator</a>&lt; uword &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12016e63b2cfe63f73584c7abc4edd2a">raw_iterator</a> () const</td></tr>
<tr class="memdesc:a12016e63b2cfe63f73584c7abc4edd2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">To iterate over the compressed data.  <br /></td></tr>
<tr class="separator:a12016e63b2cfe63f73584c7abc4edd2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2129bd431044b286d944f3c3111a008" id="r_af2129bd431044b286d944f3c3111a008"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2129bd431044b286d944f3c3111a008">append</a> (const <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a> &amp;x)</td></tr>
<tr class="memdesc:af2129bd431044b286d944f3c3111a008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the content of some other compressed bitmap at the end of the current bitmap.  <br /></td></tr>
<tr class="separator:af2129bd431044b286d944f3c3111a008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a559aa9df1e2cf81ace94c1cdc8aa65ca" id="r_a559aa9df1e2cf81ace94c1cdc8aa65ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classewah_1_1_bitmap_statistics.html">BitmapStatistics</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a559aa9df1e2cf81ace94c1cdc8aa65ca">computeStatistics</a> () const</td></tr>
<tr class="memdesc:a559aa9df1e2cf81ace94c1cdc8aa65ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">For research purposes.  <br /></td></tr>
<tr class="separator:a559aa9df1e2cf81ace94c1cdc8aa65ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc051962dacea914781b349f8ff86492" id="r_afc051962dacea914781b349f8ff86492"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classewah_1_1_bool_array.html">BoolArray</a>&lt; uword &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc051962dacea914781b349f8ff86492">toBoolArray</a> () const</td></tr>
<tr class="memdesc:afc051962dacea914781b349f8ff86492"><td class="mdescLeft">&#160;</td><td class="mdescRight">For convenience, this fully uncompresses the bitmap.  <br /></td></tr>
<tr class="separator:afc051962dacea914781b349f8ff86492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04dcdfcc69e54f348dd8c6070b91e88a" id="r_a04dcdfcc69e54f348dd8c6070b91e88a"><td class="memTemplParams" colspan="2">template&lt;class container &gt; </td></tr>
<tr class="memitem:a04dcdfcc69e54f348dd8c6070b91e88a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a04dcdfcc69e54f348dd8c6070b91e88a">appendSetBits</a> (container &amp;out, const size_t offset=0) const</td></tr>
<tr class="memdesc:a04dcdfcc69e54f348dd8c6070b91e88a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to a list of positions of "set" bits.  <br /></td></tr>
<tr class="separator:a04dcdfcc69e54f348dd8c6070b91e88a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c66c41653d71a2ced5c0f6fa46b7ad" id="r_a43c66c41653d71a2ced5c0f6fa46b7ad"><td class="memItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43c66c41653d71a2ced5c0f6fa46b7ad">toVector</a> () const</td></tr>
<tr class="memdesc:a43c66c41653d71a2ced5c0f6fa46b7ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector containing the position of the set bits in increasing order.  <br /></td></tr>
<tr class="separator:a43c66c41653d71a2ced5c0f6fa46b7ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9088d005fedc9c8efe1db0d51ea7ae5" id="r_ab9088d005fedc9c8efe1db0d51ea7ae5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9088d005fedc9c8efe1db0d51ea7ae5">numberOfOnes</a> () const</td></tr>
<tr class="memdesc:ab9088d005fedc9c8efe1db0d51ea7ae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bits set to the value 1.  <br /></td></tr>
<tr class="separator:ab9088d005fedc9c8efe1db0d51ea7ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa36daff5ae0dfef1e8d0928e54e1a6d" id="r_afa36daff5ae0dfef1e8d0928e54e1a6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa36daff5ae0dfef1e8d0928e54e1a6d">swap</a> (<a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a> &amp;x)</td></tr>
<tr class="memdesc:afa36daff5ae0dfef1e8d0928e54e1a6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the content of this bitmap with another bitmap.  <br /></td></tr>
<tr class="separator:afa36daff5ae0dfef1e8d0928e54e1a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16178aeae3bff490ce9585a81c4108c8" id="r_a16178aeae3bff490ce9585a81c4108c8"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; uword &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16178aeae3bff490ce9585a81c4108c8">getBuffer</a> () const</td></tr>
<tr class="separator:a16178aeae3bff490ce9585a81c4108c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39117a1d939bc96db71fbe879e3429b6" id="r_a39117a1d939bc96db71fbe879e3429b6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39117a1d939bc96db71fbe879e3429b6">EWAHBoolArray</a> (const <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a> &amp;other)</td></tr>
<tr class="memdesc:a39117a1d939bc96db71fbe879e3429b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Please don't copy your bitmaps! The running time complexity of a copy is the size of the compressed bitmap.  <br /></td></tr>
<tr class="separator:a39117a1d939bc96db71fbe879e3429b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ed4433b590ce38dcbf24c7311b8567" id="r_a67ed4433b590ce38dcbf24c7311b8567"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67ed4433b590ce38dcbf24c7311b8567">operator=</a> (const <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a> &amp;x)</td></tr>
<tr class="memdesc:a67ed4433b590ce38dcbf24c7311b8567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the content of one bitmap onto another.  <br /></td></tr>
<tr class="separator:a67ed4433b590ce38dcbf24c7311b8567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9017db13358721793161a4fca28d0d0c" id="r_a9017db13358721793161a4fca28d0d0c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9017db13358721793161a4fca28d0d0c">EWAHBoolArray</a> (<a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:a9017db13358721793161a4fca28d0d0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <br /></td></tr>
<tr class="separator:a9017db13358721793161a4fca28d0d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5690a4b3f7341dcdcc2b938518db9142" id="r_a5690a4b3f7341dcdcc2b938518db9142"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5690a4b3f7341dcdcc2b938518db9142">operator=</a> (<a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a> &amp;&amp;x)</td></tr>
<tr class="memdesc:a5690a4b3f7341dcdcc2b938518db9142"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <br /></td></tr>
<tr class="separator:a5690a4b3f7341dcdcc2b938518db9142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf11afa8bb4bd71c7eea38537111c883" id="r_acf11afa8bb4bd71c7eea38537111c883"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf11afa8bb4bd71c7eea38537111c883">expensive_copy</a> (const <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a> &amp;x)</td></tr>
<tr class="memdesc:acf11afa8bb4bd71c7eea38537111c883"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is equivalent to the operator =.  <br /></td></tr>
<tr class="separator:acf11afa8bb4bd71c7eea38537111c883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67ef19a1a0617c7a229982732323a2f" id="r_af67ef19a1a0617c7a229982732323a2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af67ef19a1a0617c7a229982732323a2f">logicalnot</a> (<a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a> &amp;x) const</td></tr>
<tr class="memdesc:af67ef19a1a0617c7a229982732323a2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the logical not of this bitmap in the provided container.  <br /></td></tr>
<tr class="separator:af67ef19a1a0617c7a229982732323a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a4c2a76ecf659fee41ef9ae687b7b2" id="r_a62a4c2a76ecf659fee41ef9ae687b7b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a>&lt; uword &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62a4c2a76ecf659fee41ef9ae687b7b2">logicalnot</a> () const</td></tr>
<tr class="memdesc:a62a4c2a76ecf659fee41ef9ae687b7b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the logical not of this bitmap in the provided container.  <br /></td></tr>
<tr class="separator:a62a4c2a76ecf659fee41ef9ae687b7b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4486b525cc170f7196c1b60102502ff2" id="r_a4486b525cc170f7196c1b60102502ff2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4486b525cc170f7196c1b60102502ff2">inplace_logicalnot</a> ()</td></tr>
<tr class="memdesc:a4486b525cc170f7196c1b60102502ff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the logical not operation on this bitmap.  <br /></td></tr>
<tr class="separator:a4486b525cc170f7196c1b60102502ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b491894ffe5040814c387e5f7245cf2" id="r_a0b491894ffe5040814c387e5f7245cf2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b491894ffe5040814c387e5f7245cf2">setSizeInBits</a> (const size_t size)</td></tr>
<tr class="memdesc:a0b491894ffe5040814c387e5f7245cf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">set size in bits.  <br /></td></tr>
<tr class="separator:a0b491894ffe5040814c387e5f7245cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a626dc37c4d53b26678f54f51dc4b5e8c" id="r_a626dc37c4d53b26678f54f51dc4b5e8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a626dc37c4d53b26678f54f51dc4b5e8c">fastaddStreamOfEmptyWords</a> (const bool v, size_t number)</td></tr>
<tr class="memdesc:a626dc37c4d53b26678f54f51dc4b5e8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like addStreamOfEmptyWords but addStreamOfEmptyWords but does not return the cost increase, does not update sizeinbits.  <br /></td></tr>
<tr class="separator:a626dc37c4d53b26678f54f51dc4b5e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba341896b18e6a4cb46336a1a529d34" id="r_a2ba341896b18e6a4cb46336a1a529d34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ba341896b18e6a4cb46336a1a529d34">fastaddStreamOfDirtyWords</a> (const uword *v, const size_t number)</td></tr>
<tr class="memdesc:a2ba341896b18e6a4cb46336a1a529d34"><td class="mdescLeft">&#160;</td><td class="mdescRight">LikeaddStreamOfDirtyWords but does not return the cost increse, does not update sizeinbits.  <br /></td></tr>
<tr class="separator:a2ba341896b18e6a4cb46336a1a529d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab4449878d4c14ad6011d377a47926932" id="r_ab4449878d4c14ad6011d377a47926932"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4449878d4c14ad6011d377a47926932">bitmapOf</a> (size_t n,...)</td></tr>
<tr class="separator:ab4449878d4c14ad6011d377a47926932"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class uword&gt;<br />
class ewah::EWAHBoolArray&lt; uword &gt;</div><p>This class is a compressed bitmap. </p>
<p>This is where compression happens. The underlying data structure is an STL vector. </p>

<p class="definition">Definition at line <a class="el" href="runninglengthword_8h_source.html#l00197">197</a> of file <a class="el" href="runninglengthword_8h_source.html">runninglengthword.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a84788ea33e8536ab81762d24b8e1a886" name="a84788ea33e8536ab81762d24b8e1a886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84788ea33e8536ab81762d24b8e1a886">&#9670;&#160;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classewah_1_1_e_w_a_h_bool_array_set_bit_forward_iterator.html">EWAHBoolArraySetBitForwardIterator</a>&lt;uword&gt; <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::const_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ewah_8h_source.html#l00156">156</a> of file <a class="el" href="ewah_8h_source.html">ewah.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a808a462b897cc280f4b8027b0008bfe1" name="a808a462b897cc280f4b8027b0008bfe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a808a462b897cc280f4b8027b0008bfe1">&#9670;&#160;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ewah_8h_source.html#l00154">154</a> of file <a class="el" href="ewah_8h_source.html">ewah.h</a>.</p>

</div>
</div>
<a id="ac6ab033778d1b59295cc60e2dd6d2a46" name="ac6ab033778d1b59295cc60e2dd6d2a46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6ab033778d1b59295cc60e2dd6d2a46">&#9670;&#160;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ewah_8h_source.html#l00581">581</a> of file <a class="el" href="ewah_8h_source.html">ewah.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a52bd5b1cd1404c511f6a5874524b5e4a" name="a52bd5b1cd1404c511f6a5874524b5e4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52bd5b1cd1404c511f6a5874524b5e4a">&#9670;&#160;</a></span>EWAHBoolArray() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::EWAHBoolArray </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ewah_8h_source.html#l00032">32</a> of file <a class="el" href="ewah_8h_source.html">ewah.h</a>.</p>

</div>
</div>
<a id="a39117a1d939bc96db71fbe879e3429b6" name="a39117a1d939bc96db71fbe879e3429b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39117a1d939bc96db71fbe879e3429b6">&#9670;&#160;</a></span>EWAHBoolArray() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::EWAHBoolArray </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a>&lt; uword &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Please don't copy your bitmaps! The running time complexity of a copy is the size of the compressed bitmap. </p>

<p class="definition">Definition at line <a class="el" href="ewah_8h_source.html#l00587">587</a> of file <a class="el" href="ewah_8h_source.html">ewah.h</a>.</p>

</div>
</div>
<a id="a9017db13358721793161a4fca28d0d0c" name="a9017db13358721793161a4fca28d0d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9017db13358721793161a4fca28d0d0c">&#9670;&#160;</a></span>EWAHBoolArray() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::EWAHBoolArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a>&lt; uword &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>

<p class="definition">Definition at line <a class="el" href="ewah_8h_source.html#l00606">606</a> of file <a class="el" href="ewah_8h_source.html">ewah.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad3a27432d57daa8d60a8a54256140fc0" name="ad3a27432d57daa8d60a8a54256140fc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3a27432d57daa8d60a8a54256140fc0">&#9670;&#160;</a></span>addStreamOfDirtyWords()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::addStreamOfDirtyWords </td>
          <td>(</td>
          <td class="paramtype">const uword *</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>number</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>add a stream of dirty words, returns the number of words added (storage cost increase) </p>

<p class="definition">Definition at line <a class="el" href="ewah-inl_8h_source.html#l01002">1002</a> of file <a class="el" href="ewah-inl_8h_source.html">ewah-inl.h</a>.</p>

</div>
</div>
<a id="a99b035800d9987fe09ecbfd7571daa4c" name="a99b035800d9987fe09ecbfd7571daa4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99b035800d9987fe09ecbfd7571daa4c">&#9670;&#160;</a></span>addStreamOfEmptyWords()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::addStreamOfEmptyWords </td>
          <td>(</td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>number</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>same as addEmptyWord, but you can do several in one shot! returns the number of words added (storage cost increase) </p>

<p class="definition">Definition at line <a class="el" href="ewah-inl_8h_source.html#l00898">898</a> of file <a class="el" href="ewah-inl_8h_source.html">ewah-inl.h</a>.</p>

</div>
</div>
<a id="a3f6242bbe7f1faf71c03cef84796e281" name="a3f6242bbe7f1faf71c03cef84796e281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f6242bbe7f1faf71c03cef84796e281">&#9670;&#160;</a></span>addStreamOfNegatedDirtyWords()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::addStreamOfNegatedDirtyWords </td>
          <td>(</td>
          <td class="paramtype">const uword *</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>number</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>add a stream of dirty words, each one negated, returns the number of words added (storage cost increase) </p>

<p class="definition">Definition at line <a class="el" href="ewah-inl_8h_source.html#l01069">1069</a> of file <a class="el" href="ewah-inl_8h_source.html">ewah-inl.h</a>.</p>

</div>
</div>
<a id="a9969a7dccfe1c42288ec4790cc27ee8a" name="a9969a7dccfe1c42288ec4790cc27ee8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9969a7dccfe1c42288ec4790cc27ee8a">&#9670;&#160;</a></span>addWord()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::addWord </td>
          <td>(</td>
          <td class="paramtype">const uword</td>          <td class="paramname"><span class="paramname"><em>newdata</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t</td>          <td class="paramname"><span class="paramname"><em>bitsthatmatter</em></span><span class="paramdefsep"> = </span><span class="paramdefval">8&#160;*&#160;sizeof(uword)</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>convenience method. </p>
<p>returns the number of words added (storage cost increase) </p>

<p class="definition">Definition at line <a class="el" href="ewah-inl_8h_source.html#l00475">475</a> of file <a class="el" href="ewah-inl_8h_source.html">ewah-inl.h</a>.</p>

</div>
</div>
<a id="af2129bd431044b286d944f3c3111a008" name="af2129bd431044b286d944f3c3111a008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2129bd431044b286d944f3c3111a008">&#9670;&#160;</a></span>append()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a>&lt; uword &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends the content of some other compressed bitmap at the end of the current bitmap. </p>

<p class="definition">Definition at line <a class="el" href="ewah-inl_8h_source.html#l00777">777</a> of file <a class="el" href="ewah-inl_8h_source.html">ewah-inl.h</a>.</p>

</div>
</div>
<a id="a04dcdfcc69e54f348dd8c6070b91e88a" name="a04dcdfcc69e54f348dd8c6070b91e88a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04dcdfcc69e54f348dd8c6070b91e88a">&#9670;&#160;</a></span>appendSetBits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
<div class="memtemplate">
template&lt;class container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::appendSetBits </td>
          <td>(</td>
          <td class="paramtype">container &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to a list of positions of "set" bits. </p>
<p>The recommended container is vector&lt;size_t&gt;.</p>
<p>See also <a class="el" href="#aecb8c572192eb6e11da029d76a0066b5" title="Retrieve the set bits.">toArray()</a>. </p>

<p class="definition">Definition at line <a class="el" href="ewah-inl_8h_source.html#l00845">845</a> of file <a class="el" href="ewah-inl_8h_source.html">ewah-inl.h</a>.</p>

</div>
</div>
<a id="a7fb78ae6e98b0668facae5b40387a6ce" name="a7fb78ae6e98b0668facae5b40387a6ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fb78ae6e98b0668facae5b40387a6ce">&#9670;&#160;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classewah_1_1_e_w_a_h_bool_array_set_bit_forward_iterator.html">const_iterator</a> <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator that can be used to access the position of the set bits. </p>
<p>The running time complexity of a full scan is proportional to the number of set bits: be aware that if you have long strings of 1s, this can be very inefficient.</p>
<p>It can be much faster to use the toArray method if you want to retrieve the set bits. </p>

<p class="definition">Definition at line <a class="el" href="ewah_8h_source.html#l00168">168</a> of file <a class="el" href="ewah_8h_source.html">ewah.h</a>.</p>

</div>
</div>
<a id="ab4449878d4c14ad6011d377a47926932" name="ab4449878d4c14ad6011d377a47926932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4449878d4c14ad6011d377a47926932">&#9670;&#160;</a></span>bitmapOf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a> <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::bitmapOf </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ewah_8h_source.html#l00034">34</a> of file <a class="el" href="ewah_8h_source.html">ewah.h</a>.</p>

</div>
</div>
<a id="a481f8a644db093edc1fbf85f2c07fbf3" name="a481f8a644db093edc1fbf85f2c07fbf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a481f8a644db093edc1fbf85f2c07fbf3">&#9670;&#160;</a></span>bufferSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::bufferSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>size (in words) of the underlying STL vector. </p>

<p class="definition">Definition at line <a class="el" href="ewah_8h_source.html#l00470">470</a> of file <a class="el" href="ewah_8h_source.html">ewah.h</a>.</p>

</div>
</div>
<a id="a559aa9df1e2cf81ace94c1cdc8aa65ca" name="a559aa9df1e2cf81ace94c1cdc8aa65ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a559aa9df1e2cf81ace94c1cdc8aa65ca">&#9670;&#160;</a></span>computeStatistics()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classewah_1_1_bitmap_statistics.html">BitmapStatistics</a> <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::computeStatistics </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For research purposes. </p>
<p>This computes the number of dirty words and the number of compressed words. </p>

<p class="definition">Definition at line <a class="el" href="ewah-inl_8h_source.html#l01635">1635</a> of file <a class="el" href="ewah-inl_8h_source.html">ewah-inl.h</a>.</p>

</div>
</div>
<a id="a627a015ab2f8837f15d0b1bf15b2c9bc" name="a627a015ab2f8837f15d0b1bf15b2c9bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a627a015ab2f8837f15d0b1bf15b2c9bc">&#9670;&#160;</a></span>debugprintout()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::debugprintout </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints a verbose description of the content of the compressed bitmap. </p>

<p class="definition">Definition at line <a class="el" href="ewah-inl_8h_source.html#l01651">1651</a> of file <a class="el" href="ewah-inl_8h_source.html">ewah-inl.h</a>.</p>

</div>
</div>
<a id="aaee92b036e93865f09414d67417a26f2" name="aaee92b036e93865f09414d67417a26f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaee92b036e93865f09414d67417a26f2">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if no bit is set. </p>

<p class="definition">Definition at line <a class="el" href="ewah_8h_source.html#l00081">81</a> of file <a class="el" href="ewah_8h_source.html">ewah.h</a>.</p>

</div>
</div>
<a id="ac22911991183267851a7c948433d392d" name="ac22911991183267851a7c948433d392d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac22911991183267851a7c948433d392d">&#9670;&#160;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classewah_1_1_e_w_a_h_bool_array_set_bit_forward_iterator.html">const_iterator</a> &amp; <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Basically a bogus iterator that can be used together with <a class="el" href="#a7fb78ae6e98b0668facae5b40387a6ce" title="Returns an iterator that can be used to access the position of the set bits.">begin()</a> for constructions such as for(EWAHBoolArray&lt;uword&gt;::iterator i = b.begin(); i!=b.end(); ++i) {}. </p>

<p class="definition">Definition at line <a class="el" href="ewah_8h_source.html#l00177">177</a> of file <a class="el" href="ewah_8h_source.html">ewah.h</a>.</p>

</div>
</div>
<a id="acf11afa8bb4bd71c7eea38537111c883" name="acf11afa8bb4bd71c7eea38537111c883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf11afa8bb4bd71c7eea38537111c883">&#9670;&#160;</a></span>expensive_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::expensive_copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a>&lt; uword &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is equivalent to the operator =. </p>
<p>It is used to keep in mind that assignment can be expensive.</p>
<p>if you don't care to copy the bitmap (performance-wise), use this! </p>

<p class="definition">Definition at line <a class="el" href="ewah_8h_source.html#l00626">626</a> of file <a class="el" href="ewah_8h_source.html">ewah.h</a>.</p>

</div>
</div>
<a id="a2ba341896b18e6a4cb46336a1a529d34" name="a2ba341896b18e6a4cb46336a1a529d34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ba341896b18e6a4cb46336a1a529d34">&#9670;&#160;</a></span>fastaddStreamOfDirtyWords()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::fastaddStreamOfDirtyWords </td>
          <td>(</td>
          <td class="paramtype">const uword *</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>number</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>LikeaddStreamOfDirtyWords but does not return the cost increse, does not update sizeinbits. </p>

<p class="definition">Definition at line <a class="el" href="ewah-inl_8h_source.html#l01036">1036</a> of file <a class="el" href="ewah-inl_8h_source.html">ewah-inl.h</a>.</p>

</div>
</div>
<a id="a626dc37c4d53b26678f54f51dc4b5e8c" name="a626dc37c4d53b26678f54f51dc4b5e8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a626dc37c4d53b26678f54f51dc4b5e8c">&#9670;&#160;</a></span>fastaddStreamOfEmptyWords()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::fastaddStreamOfEmptyWords </td>
          <td>(</td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>number</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like addStreamOfEmptyWords but addStreamOfEmptyWords but does not return the cost increase, does not update sizeinbits. </p>

<p class="definition">Definition at line <a class="el" href="ewah-inl_8h_source.html#l00953">953</a> of file <a class="el" href="ewah-inl_8h_source.html">ewah-inl.h</a>.</p>

</div>
</div>
<a id="a48045ede9ca6065b8c7b7f7f8e9a0260" name="a48045ede9ca6065b8c7b7f7f8e9a0260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48045ede9ca6065b8c7b7f7f8e9a0260">&#9670;&#160;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::get </td>
          <td>(</td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query the value of bit i. </p>
<p>This runs in time proportional to the size of the bitmap. This is not meant to be use in a performance-sensitive context.</p>
<p>(This implementation is based on zhenjl's Go version of JavaEWAH.) </p>

<p class="definition">Definition at line <a class="el" href="ewah_8h_source.html#l00058">58</a> of file <a class="el" href="ewah_8h_source.html">ewah.h</a>.</p>

</div>
</div>
<a id="a16178aeae3bff490ce9585a81c4108c8" name="a16178aeae3bff490ce9585a81c4108c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16178aeae3bff490ce9585a81c4108c8">&#9670;&#160;</a></span>getBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; uword &gt; &amp; <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::getBuffer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ewah_8h_source.html#l00579">579</a> of file <a class="el" href="ewah_8h_source.html">ewah.h</a>.</p>

</div>
</div>
<a id="a4486b525cc170f7196c1b60102502ff2" name="a4486b525cc170f7196c1b60102502ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4486b525cc170f7196c1b60102502ff2">&#9670;&#160;</a></span>inplace_logicalnot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::inplace_logicalnot </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the logical not operation on this bitmap. </p>
<p>Running time complexity is proportional to the compressed size of the bitmap. The current bitmap is not modified.</p>
<p>This function takes into account the sizeInBits value. You may need to call "padWithZeroes" to adjust the sizeInBits. </p>

<p class="definition">Definition at line <a class="el" href="ewah-inl_8h_source.html#l00294">294</a> of file <a class="el" href="ewah-inl_8h_source.html">ewah-inl.h</a>.</p>

</div>
</div>
<a id="ae251a6683ce14932c4bbe450ea4929ba" name="ae251a6683ce14932c4bbe450ea4929ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae251a6683ce14932c4bbe450ea4929ba">&#9670;&#160;</a></span>intersects()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::intersects </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a>&lt; uword &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>tests whether the bitmaps "intersect" (have at least one 1-bit at the same position). </p>
<p>This function does not modify the existing bitmaps. It is faster than calling logicaland. </p>

<p class="definition">Definition at line <a class="el" href="ewah-inl_8h_source.html#l01594">1594</a> of file <a class="el" href="ewah-inl_8h_source.html">ewah-inl.h</a>.</p>

</div>
</div>
<a id="a6b615ad43a09d293dd3c27a307c56396" name="a6b615ad43a09d293dd3c27a307c56396"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b615ad43a09d293dd3c27a307c56396">&#9670;&#160;</a></span>logicaland() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a> <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::logicaland </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a>&lt; uword &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>computes the logical and with another compressed bitmap Return the answer Running time complexity is proportional to the sum of the compressed bitmap sizes. </p>
<p>The <a class="el" href="#aba5c323355b42ad471317ff17fdd2b60" title="Return the size in bits of this bitmap (this refers to the uncompressed size in bits).">sizeInBits()</a> of the result is equal to the maximum that of the current bitmap's <a class="el" href="#aba5c323355b42ad471317ff17fdd2b60" title="Return the size in bits of this bitmap (this refers to the uncompressed size in bits).">sizeInBits()</a> and that of a.sizeInBits(). </p>

<p class="definition">Definition at line <a class="el" href="ewah_8h_source.html#l00207">207</a> of file <a class="el" href="ewah_8h_source.html">ewah.h</a>.</p>

</div>
</div>
<a id="ab2bbba4a8293ba6f778dff81b7e8c1ae" name="ab2bbba4a8293ba6f778dff81b7e8c1ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2bbba4a8293ba6f778dff81b7e8c1ae">&#9670;&#160;</a></span>logicaland() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::logicaland </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a>&lt; uword &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a>&lt; uword &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>container</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the logical and with another compressed bitmap answer goes into container Running time complexity is proportional to the sum of the compressed bitmap sizes. </p>
<p>The <a class="el" href="#aba5c323355b42ad471317ff17fdd2b60" title="Return the size in bits of this bitmap (this refers to the uncompressed size in bits).">sizeInBits()</a> of the result is equal to the maximum that of the current bitmap's <a class="el" href="#aba5c323355b42ad471317ff17fdd2b60" title="Return the size in bits of this bitmap (this refers to the uncompressed size in bits).">sizeInBits()</a> and that of a.sizeInBits(). </p>

<p class="definition">Definition at line <a class="el" href="ewah-inl_8h_source.html#l01381">1381</a> of file <a class="el" href="ewah-inl_8h_source.html">ewah-inl.h</a>.</p>

</div>
</div>
<a id="a426745653634283858eb7202a708078c" name="a426745653634283858eb7202a708078c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a426745653634283858eb7202a708078c">&#9670;&#160;</a></span>logicalandcount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::logicalandcount </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a>&lt; uword &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the size (in number of set bits) of the logical and with another compressed bitmap Running time complexity is proportional to the sum of the compressed bitmap sizes. </p>

<p class="definition">Definition at line <a class="el" href="ewah-inl_8h_source.html#l01555">1555</a> of file <a class="el" href="ewah-inl_8h_source.html">ewah-inl.h</a>.</p>

</div>
</div>
<a id="a35920c8869a091b08e2d18c74af43d7c" name="a35920c8869a091b08e2d18c74af43d7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35920c8869a091b08e2d18c74af43d7c">&#9670;&#160;</a></span>logicalandnot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a> <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::logicalandnot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a>&lt; uword &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>computes the logical and not with another compressed bitmap Return the answer Running time complexity is proportional to the sum of the compressed bitmap sizes. </p>
<p>The <a class="el" href="#aba5c323355b42ad471317ff17fdd2b60" title="Return the size in bits of this bitmap (this refers to the uncompressed size in bits).">sizeInBits()</a> of the result should be equal to that of the current bitmap irrespective of a.sizeInBits(). </p>

<p class="definition">Definition at line <a class="el" href="ewah_8h_source.html#l00249">249</a> of file <a class="el" href="ewah_8h_source.html">ewah.h</a>.</p>

</div>
</div>
<a id="a39c960408fd986b621df413dbb0ee652" name="a39c960408fd986b621df413dbb0ee652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39c960408fd986b621df413dbb0ee652">&#9670;&#160;</a></span>logicalandnot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::logicalandnot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a>&lt; uword &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a>&lt; uword &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>container</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the logical and with another compressed bitmap answer goes into container Running time complexity is proportional to the sum of the compressed bitmap sizes. </p>
<p>The <a class="el" href="#aba5c323355b42ad471317ff17fdd2b60" title="Return the size in bits of this bitmap (this refers to the uncompressed size in bits).">sizeInBits()</a> of the result should be equal to that of the current bitmap irrespective of a.sizeInBits(). </p>

<p class="definition">Definition at line <a class="el" href="ewah-inl_8h_source.html#l01436">1436</a> of file <a class="el" href="ewah-inl_8h_source.html">ewah-inl.h</a>.</p>

</div>
</div>
<a id="aac1ae1bd3065afae9dd6c5d4717636da" name="aac1ae1bd3065afae9dd6c5d4717636da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac1ae1bd3065afae9dd6c5d4717636da">&#9670;&#160;</a></span>logicalandnotcount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::logicalandnotcount </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a>&lt; uword &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the size (in number of set bits) of the logical and not with another compressed bitmap Running time complexity is proportional to the sum of the compressed bitmap sizes. </p>

<p class="definition">Definition at line <a class="el" href="ewah-inl_8h_source.html#l01505">1505</a> of file <a class="el" href="ewah-inl_8h_source.html">ewah-inl.h</a>.</p>

</div>
</div>
<a id="a62a4c2a76ecf659fee41ef9ae687b7b2" name="a62a4c2a76ecf659fee41ef9ae687b7b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62a4c2a76ecf659fee41ef9ae687b7b2">&#9670;&#160;</a></span>logicalnot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a>&lt; uword &gt; <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::logicalnot </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the logical not of this bitmap in the provided container. </p>
<p>This function takes into account the sizeInBits value. You may need to call "padWithZeroes" to adjust the sizeInBits. </p>

<p class="definition">Definition at line <a class="el" href="ewah_8h_source.html#l00646">646</a> of file <a class="el" href="ewah_8h_source.html">ewah.h</a>.</p>

</div>
</div>
<a id="af67ef19a1a0617c7a229982732323a2f" name="af67ef19a1a0617c7a229982732323a2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af67ef19a1a0617c7a229982732323a2f">&#9670;&#160;</a></span>logicalnot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::logicalnot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a>&lt; uword &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the logical not of this bitmap in the provided container. </p>
<p>This function takes into account the sizeInBits value. You may need to call "padWithZeroes" to adjust the sizeInBits. </p>

<p class="definition">Definition at line <a class="el" href="ewah-inl_8h_source.html#l00418">418</a> of file <a class="el" href="ewah-inl_8h_source.html">ewah-inl.h</a>.</p>

</div>
</div>
<a id="a0aee1e8a6225d49a1e65eb22befbed0a" name="a0aee1e8a6225d49a1e65eb22befbed0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aee1e8a6225d49a1e65eb22befbed0a">&#9670;&#160;</a></span>logicalor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a> <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::logicalor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a>&lt; uword &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>computes the logical or with another compressed bitmap Return the answer Running time complexity is proportional to the sum of the compressed bitmap sizes. </p>
<p>If you have many bitmaps, see fast_logicalor.</p>
<p>The <a class="el" href="#aba5c323355b42ad471317ff17fdd2b60" title="Return the size in bits of this bitmap (this refers to the uncompressed size in bits).">sizeInBits()</a> of the result is equal to the maximum that of the current bitmap's <a class="el" href="#aba5c323355b42ad471317ff17fdd2b60" title="Return the size in bits of this bitmap (this refers to the uncompressed size in bits).">sizeInBits()</a> and that of a.sizeInBits(). </p>

<p class="definition">Definition at line <a class="el" href="ewah_8h_source.html#l00318">318</a> of file <a class="el" href="ewah_8h_source.html">ewah.h</a>.</p>

</div>
</div>
<a id="a248b3b85d65973b31b097339cf7e6598" name="a248b3b85d65973b31b097339cf7e6598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a248b3b85d65973b31b097339cf7e6598">&#9670;&#160;</a></span>logicalor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::logicalor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a>&lt; uword &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a>&lt; uword &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>container</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the logical or with another compressed bitmap answer goes into container Running time complexity is proportional to the sum of the compressed bitmap sizes. </p>
<p>If you have many bitmaps, see fast_logicalor_tocontainer.</p>
<p>The <a class="el" href="#aba5c323355b42ad471317ff17fdd2b60" title="Return the size in bits of this bitmap (this refers to the uncompressed size in bits).">sizeInBits()</a> of the result is equal to the maximum that of the current bitmap's <a class="el" href="#aba5c323355b42ad471317ff17fdd2b60" title="Return the size in bits of this bitmap (this refers to the uncompressed size in bits).">sizeInBits()</a> and that of a.sizeInBits(). </p>

<p class="definition">Definition at line <a class="el" href="ewah-inl_8h_source.html#l01193">1193</a> of file <a class="el" href="ewah-inl_8h_source.html">ewah-inl.h</a>.</p>

</div>
</div>
<a id="aaf41e834801112e7e109c7faa9c95539" name="aaf41e834801112e7e109c7faa9c95539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf41e834801112e7e109c7faa9c95539">&#9670;&#160;</a></span>logicalorcount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::logicalorcount </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a>&lt; uword &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the size (in number of set bits) of the logical or with another compressed bitmap Running time complexity is proportional to the sum of the compressed bitmap sizes. </p>

<p class="definition">Definition at line <a class="el" href="ewah-inl_8h_source.html#l01243">1243</a> of file <a class="el" href="ewah-inl_8h_source.html">ewah-inl.h</a>.</p>

</div>
</div>
<a id="a94e407bdfd92cc38ea4d5929177e9ee1" name="a94e407bdfd92cc38ea4d5929177e9ee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94e407bdfd92cc38ea4d5929177e9ee1">&#9670;&#160;</a></span>logicalxor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a> <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::logicalxor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a>&lt; uword &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>computes the logical xor with another compressed bitmap Return the answer Running time complexity is proportional to the sum of the compressed bitmap sizes. </p>
<p>The <a class="el" href="#aba5c323355b42ad471317ff17fdd2b60" title="Return the size in bits of this bitmap (this refers to the uncompressed size in bits).">sizeInBits()</a> of the result is equal to the maximum that of the current bitmap's <a class="el" href="#aba5c323355b42ad471317ff17fdd2b60" title="Return the size in bits of this bitmap (this refers to the uncompressed size in bits).">sizeInBits()</a> and that of a.sizeInBits(). </p>

<p class="definition">Definition at line <a class="el" href="ewah_8h_source.html#l00349">349</a> of file <a class="el" href="ewah_8h_source.html">ewah.h</a>.</p>

</div>
</div>
<a id="a0effb2623cb241062ffad9f26a5601e5" name="a0effb2623cb241062ffad9f26a5601e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0effb2623cb241062ffad9f26a5601e5">&#9670;&#160;</a></span>logicalxor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::logicalxor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a>&lt; uword &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a>&lt; uword &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>container</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the logical xor with another compressed bitmap answer goes into container Running time complexity is proportional to the sum of the compressed bitmap sizes. </p>
<p>The <a class="el" href="#aba5c323355b42ad471317ff17fdd2b60" title="Return the size in bits of this bitmap (this refers to the uncompressed size in bits).">sizeInBits()</a> of the result is equal to the maximum that of the current bitmap's <a class="el" href="#aba5c323355b42ad471317ff17fdd2b60" title="Return the size in bits of this bitmap (this refers to the uncompressed size in bits).">sizeInBits()</a> and that of a.sizeInBits(). </p>

<p class="definition">Definition at line <a class="el" href="ewah-inl_8h_source.html#l01288">1288</a> of file <a class="el" href="ewah-inl_8h_source.html">ewah-inl.h</a>.</p>

</div>
</div>
<a id="aa71f3e9a634b503b1842b161d46d41ea" name="aa71f3e9a634b503b1842b161d46d41ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa71f3e9a634b503b1842b161d46d41ea">&#9670;&#160;</a></span>logicalxorcount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::logicalxorcount </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a>&lt; uword &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the size (in number of set bits) of the logical xor with another compressed bitmap Running time complexity is proportional to the sum of the compressed bitmap sizes. </p>

<p class="definition">Definition at line <a class="el" href="ewah-inl_8h_source.html#l01332">1332</a> of file <a class="el" href="ewah-inl_8h_source.html">ewah-inl.h</a>.</p>

</div>
</div>
<a id="a1a5e399a845e3a991bd9d33db6fa40e0" name="a1a5e399a845e3a991bd9d33db6fa40e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a5e399a845e3a991bd9d33db6fa40e0">&#9670;&#160;</a></span>makeSameSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::makeSameSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a>&lt; uword &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make sure the two bitmaps have the same size (padding with zeroes if necessary). </p>
<p>It has constant running time complexity.</p>
<p>This is useful when calling "logicalnot" functions.</p>
<p>This can an adverse effect of performance, especially when computing intersections. </p>

<p class="definition">Definition at line <a class="el" href="ewah_8h_source.html#l00147">147</a> of file <a class="el" href="ewah_8h_source.html">ewah.h</a>.</p>

</div>
</div>
<a id="ab9088d005fedc9c8efe1db0d51ea7ae5" name="ab9088d005fedc9c8efe1db0d51ea7ae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9088d005fedc9c8efe1db0d51ea7ae5">&#9670;&#160;</a></span>numberOfOnes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::numberOfOnes </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of bits set to the value 1. </p>
<p>The running time complexity is proportional to the compressed size of the bitmap.</p>
<p>This is sometimes called the cardinality. </p>

<p class="definition">Definition at line <a class="el" href="ewah-inl_8h_source.html#l00365">365</a> of file <a class="el" href="ewah-inl_8h_source.html">ewah-inl.h</a>.</p>

</div>
</div>
<a id="ac7a3f4f66dab5e9e55e309621b769b99" name="ac7a3f4f66dab5e9e55e309621b769b99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7a3f4f66dab5e9e55e309621b769b99">&#9670;&#160;</a></span>operator std::string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::operator std::string </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform into a string that presents a list of set bits. </p>
<p>The running time is linear in the compressed size of the bitmap. </p>

<p class="definition">Definition at line <a class="el" href="ewah_8h_source.html#l00120">120</a> of file <a class="el" href="ewah_8h_source.html">ewah.h</a>.</p>

</div>
</div>
<a id="af31f1d4b93490905c0892a74e46216c9" name="af31f1d4b93490905c0892a74e46216c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af31f1d4b93490905c0892a74e46216c9">&#9670;&#160;</a></span>operator!=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classewah_1_1_bool_array.html">BoolArray</a>&lt; uword &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ewah-inl_8h_source.html#l00892">892</a> of file <a class="el" href="ewah-inl_8h_source.html">ewah-inl.h</a>.</p>

</div>
</div>
<a id="ad2a77cb0c3ae12baa53894a3ac01ea11" name="ad2a77cb0c3ae12baa53894a3ac01ea11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2a77cb0c3ae12baa53894a3ac01ea11">&#9670;&#160;</a></span>operator!=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a>&lt; uword &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>We define two <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html" title="This class is a compressed bitmap.">EWAHBoolArray</a> as being different if they do not have the same set bits. </p>
<p>Alternatively, B1!=B2 if and only if cardinality(B1 XOR B2) &gt;0. </p>

<p class="definition">Definition at line <a class="el" href="ewah-inl_8h_source.html#l00881">881</a> of file <a class="el" href="ewah-inl_8h_source.html">ewah-inl.h</a>.</p>

</div>
</div>
<a id="ac1521faaf0da44fd6af2fbc8672e7a96" name="ac1521faaf0da44fd6af2fbc8672e7a96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1521faaf0da44fd6af2fbc8672e7a96">&#9670;&#160;</a></span>operator&amp;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a> <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a>&lt; uword &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>calls logicaland </p>

<p class="definition">Definition at line <a class="el" href="ewah_8h_source.html#l00216">216</a> of file <a class="el" href="ewah_8h_source.html">ewah.h</a>.</p>

</div>
</div>
<a id="a28ad4e6e2045b292600d3cb0dcc1fab5" name="a28ad4e6e2045b292600d3cb0dcc1fab5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28ad4e6e2045b292600d3cb0dcc1fab5">&#9670;&#160;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a> <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a>&lt; uword &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>calls logicalandnot </p>

<p class="definition">Definition at line <a class="el" href="ewah_8h_source.html#l00235">235</a> of file <a class="el" href="ewah_8h_source.html">ewah.h</a>.</p>

</div>
</div>
<a id="a67ed4433b590ce38dcbf24c7311b8567" name="a67ed4433b590ce38dcbf24c7311b8567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67ed4433b590ce38dcbf24c7311b8567">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a> &amp; <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a>&lt; uword &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the content of one bitmap onto another. </p>
<p>Running time complexity is proportional to the size of the compressed bitmap. please, never hard-copy this object. Use the swap method if you must. </p>

<p class="definition">Definition at line <a class="el" href="ewah_8h_source.html#l00596">596</a> of file <a class="el" href="ewah_8h_source.html">ewah.h</a>.</p>

</div>
</div>
<a id="a5690a4b3f7341dcdcc2b938518db9142" name="a5690a4b3f7341dcdcc2b938518db9142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5690a4b3f7341dcdcc2b938518db9142">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a> &amp; <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a>&lt; uword &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>

<p class="definition">Definition at line <a class="el" href="ewah_8h_source.html#l00613">613</a> of file <a class="el" href="ewah_8h_source.html">ewah.h</a>.</p>

</div>
</div>
<a id="aacbaff6cc426f05ad72cab4e591e919d" name="aacbaff6cc426f05ad72cab4e591e919d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacbaff6cc426f05ad72cab4e591e919d">&#9670;&#160;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classewah_1_1_bool_array.html">BoolArray</a>&lt; uword &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ewah-inl_8h_source.html#l00886">886</a> of file <a class="el" href="ewah-inl_8h_source.html">ewah-inl.h</a>.</p>

</div>
</div>
<a id="a016138a6037ff061b17e931be4ab9d48" name="a016138a6037ff061b17e931be4ab9d48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a016138a6037ff061b17e931be4ab9d48">&#9670;&#160;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a>&lt; uword &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>We define two <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html" title="This class is a compressed bitmap.">EWAHBoolArray</a> as being equal if they have the same set bits. </p>
<p>Alternatively, B1==B2 if and only if cardinality(B1 XOR B2) ==0. </p>

<p class="definition">Definition at line <a class="el" href="ewah-inl_8h_source.html#l00720">720</a> of file <a class="el" href="ewah-inl_8h_source.html">ewah-inl.h</a>.</p>

</div>
</div>
<a id="a357e1917ef3ec396fde72c54d523feaf" name="a357e1917ef3ec396fde72c54d523feaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a357e1917ef3ec396fde72c54d523feaf">&#9670;&#160;</a></span>operator^()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a> <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::operator^ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a>&lt; uword &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>calls logicalxor </p>

<p class="definition">Definition at line <a class="el" href="ewah_8h_source.html#l00358">358</a> of file <a class="el" href="ewah_8h_source.html">ewah.h</a>.</p>

</div>
</div>
<a id="a4a131166e4df8e01c5f66a3eb52cc685" name="a4a131166e4df8e01c5f66a3eb52cc685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a131166e4df8e01c5f66a3eb52cc685">&#9670;&#160;</a></span>operator|()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a> <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::operator| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a>&lt; uword &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>calls logicalor </p>

<p class="definition">Definition at line <a class="el" href="ewah_8h_source.html#l00327">327</a> of file <a class="el" href="ewah_8h_source.html">ewah.h</a>.</p>

</div>
</div>
<a id="a2436a4ea098bdab8cf7db4d2cdceaa16" name="a2436a4ea098bdab8cf7db4d2cdceaa16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2436a4ea098bdab8cf7db4d2cdceaa16">&#9670;&#160;</a></span>padWithZeroes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::padWithZeroes </td>
          <td>(</td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>totalbits</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>make sure the size of the array is totalbits bits by padding with zeroes. </p>
<p>returns the number of words added (storage cost increase).</p>
<p>This is useful when calling "logicalnot" functions.</p>
<p>This can an adverse effect of performance, especially when computing intersections. </p>

<p class="definition">Definition at line <a class="el" href="ewah-inl_8h_source.html#l00635">635</a> of file <a class="el" href="ewah-inl_8h_source.html">ewah-inl.h</a>.</p>

</div>
</div>
<a id="ad431d2437ba346f2d65ceee781364ab4" name="ad431d2437ba346f2d65ceee781364ab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad431d2437ba346f2d65ceee781364ab4">&#9670;&#160;</a></span>printout()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::printout </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>o</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::cout</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ewah_8h_source.html#l00380">380</a> of file <a class="el" href="ewah_8h_source.html">ewah.h</a>.</p>

</div>
</div>
<a id="a12016e63b2cfe63f73584c7abc4edd2a" name="a12016e63b2cfe63f73584c7abc4edd2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12016e63b2cfe63f73584c7abc4edd2a">&#9670;&#160;</a></span>raw_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classewah_1_1_e_w_a_h_bool_array_raw_iterator.html">EWAHBoolArrayRawIterator</a>&lt; uword &gt; <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::raw_iterator </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To iterate over the compressed data. </p>
<p>Can be faster than any other iterator. Running time complexity of a full scan is proportional to the compressed size of the bitmap. </p>

<p class="definition">Definition at line <a class="el" href="ewah-inl_8h_source.html#l00715">715</a> of file <a class="el" href="ewah-inl_8h_source.html">ewah-inl.h</a>.</p>

</div>
</div>
<a id="adf6fe7cb001de949c6254d61bdaa28bc" name="adf6fe7cb001de949c6254d61bdaa28bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf6fe7cb001de949c6254d61bdaa28bc">&#9670;&#160;</a></span>read() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::read </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>capacity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>savesizeinbits</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>same as read(std::istream...), except that you provide a char pointer and a "capacity" (in bytes). </p>
<p>The function never reads at or beyond "in+capacity". If the detected storage exceeds the given capacity, the value zero is returned: it should be considered an error. Otherwise, the number of bytes read is returned. </p>

<p class="definition">Definition at line <a class="el" href="ewah-inl_8h_source.html#l00581">581</a> of file <a class="el" href="ewah-inl_8h_source.html">ewah-inl.h</a>.</p>

</div>
</div>
<a id="ab28a0765db41edf55399c9e883bf1130" name="ab28a0765db41edf55399c9e883bf1130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab28a0765db41edf55399c9e883bf1130">&#9670;&#160;</a></span>read() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::read </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>savesizeinbits</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this is the counterpart to the write method. </p>
<p>if you set savesizeinbits=false, then you are responsible for setting the value fo the attribute sizeinbits (see method setSizeInBits).</p>
<p>Returns how many bytes were queried from the stream. </p>

<p class="definition">Definition at line <a class="el" href="ewah-inl_8h_source.html#l00556">556</a> of file <a class="el" href="ewah-inl_8h_source.html">ewah-inl.h</a>.</p>

</div>
</div>
<a id="aa6b066f3fe7b02b18e3505ace63ad1ed" name="aa6b066f3fe7b02b18e3505ace63ad1ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6b066f3fe7b02b18e3505ace63ad1ed">&#9670;&#160;</a></span>readBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::readBuffer </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>buffersize</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>read the buffer from a stream, see method writeBuffer. </p>
<p>this is for advanced users. </p>

<p class="definition">Definition at line <a class="el" href="ewah-inl_8h_source.html#l00495">495</a> of file <a class="el" href="ewah-inl_8h_source.html">ewah-inl.h</a>.</p>

</div>
</div>
<a id="ad172a0052454ec59aafd2140df69c398" name="ad172a0052454ec59aafd2140df69c398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad172a0052454ec59aafd2140df69c398">&#9670;&#160;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::reset </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>clear the content of the bitmap. </p>
<p>It does not release the memory. </p>

<p class="definition">Definition at line <a class="el" href="ewah_8h_source.html#l00365">365</a> of file <a class="el" href="ewah_8h_source.html">ewah.h</a>.</p>

</div>
</div>
<a id="a7c5d9990d6efccf50fcacb766ee45169" name="a7c5d9990d6efccf50fcacb766ee45169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c5d9990d6efccf50fcacb766ee45169">&#9670;&#160;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::set </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the ith bit to true (starting at zero). </p>
<p>Auto-expands the bitmap. It has constant running time complexity. Note that you must set the bits in increasing order: set(1), set(2) is ok; set(2), set(1) is not ok. set(100), set(100) is also not ok.</p>
<p>Note: by design EWAH is not an updatable data structure in the sense that once bit 1000 is set, you cannot change the value of bits 0 to 1000.</p>
<p>Returns true if the value of the bit was changed, and false otherwise. (In practice, if you set the bits in strictly increasing order, it should always return true.) </p>

<p class="definition">Definition at line <a class="el" href="ewah-inl_8h_source.html#l00257">257</a> of file <a class="el" href="ewah-inl_8h_source.html">ewah-inl.h</a>.</p>

</div>
</div>
<a id="a0b491894ffe5040814c387e5f7245cf2" name="a0b491894ffe5040814c387e5f7245cf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b491894ffe5040814c387e5f7245cf2">&#9670;&#160;</a></span>setSizeInBits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::setSizeInBits </td>
          <td>(</td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set size in bits. </p>
<p>This does not affect the compressed size. It runs in constant time. This should not normally be used, except as part of a deserialization process. </p>

<p class="definition">Definition at line <a class="el" href="ewah_8h_source.html#l00668">668</a> of file <a class="el" href="ewah_8h_source.html">ewah.h</a>.</p>

</div>
</div>
<a id="aba5c323355b42ad471317ff17fdd2b60" name="aba5c323355b42ad471317ff17fdd2b60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba5c323355b42ad471317ff17fdd2b60">&#9670;&#160;</a></span>sizeInBits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::sizeInBits </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the size in bits of this bitmap (this refers to the uncompressed size in bits). </p>
<p>You can increase it with <a class="el" href="#a2436a4ea098bdab8cf7db4d2cdceaa16" title="make sure the size of the array is totalbits bits by padding with zeroes.">padWithZeroes()</a> </p>

<p class="definition">Definition at line <a class="el" href="ewah_8h_source.html#l00395">395</a> of file <a class="el" href="ewah_8h_source.html">ewah.h</a>.</p>

</div>
</div>
<a id="a3cdac35befecda0dd94b804248b474f4" name="a3cdac35befecda0dd94b804248b474f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cdac35befecda0dd94b804248b474f4">&#9670;&#160;</a></span>sizeInBytes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::sizeInBytes </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the size of the buffer in bytes. </p>
<p>This is equivalent to the storage cost, minus some overhead. See sizeOnDisk to get the actual storage cost with overhead. </p>

<p class="definition">Definition at line <a class="el" href="ewah_8h_source.html#l00402">402</a> of file <a class="el" href="ewah_8h_source.html">ewah.h</a>.</p>

</div>
</div>
<a id="ab8f3e7d0bfbb32c44e548926897d5f8d" name="ab8f3e7d0bfbb32c44e548926897d5f8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8f3e7d0bfbb32c44e548926897d5f8d">&#9670;&#160;</a></span>sizeOnDisk()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::sizeOnDisk </td>
          <td>(</td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>savesizeinbits</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the size on disk assuming that it was saved using the method "write". </p>

<p class="definition">Definition at line <a class="el" href="ewah-inl_8h_source.html#l01674">1674</a> of file <a class="el" href="ewah-inl_8h_source.html">ewah-inl.h</a>.</p>

</div>
</div>
<a id="afa36daff5ae0dfef1e8d0928e54e1a6d" name="afa36daff5ae0dfef1e8d0928e54e1a6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa36daff5ae0dfef1e8d0928e54e1a6d">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a>&lt; uword &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap the content of this bitmap with another bitmap. </p>
<p>No copying is done. (Running time complexity is constant.) </p>

<p class="definition">Definition at line <a class="el" href="ewah-inl_8h_source.html#l00766">766</a> of file <a class="el" href="ewah-inl_8h_source.html">ewah-inl.h</a>.</p>

</div>
</div>
<a id="aecb8c572192eb6e11da029d76a0066b5" name="aecb8c572192eb6e11da029d76a0066b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecb8c572192eb6e11da029d76a0066b5">&#9670;&#160;</a></span>toArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; size_t &gt; <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::toArray </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the set bits. </p>
<p>Can be much faster than iterating through the set bits with an iterator. </p>

<p class="definition">Definition at line <a class="el" href="ewah-inl_8h_source.html#l00383">383</a> of file <a class="el" href="ewah-inl_8h_source.html">ewah-inl.h</a>.</p>

</div>
</div>
<a id="afc051962dacea914781b349f8ff86492" name="afc051962dacea914781b349f8ff86492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc051962dacea914781b349f8ff86492">&#9670;&#160;</a></span>toBoolArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classewah_1_1_bool_array.html">BoolArray</a>&lt; uword &gt; <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::toBoolArray </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For convenience, this fully uncompresses the bitmap. </p>
<p>Not fast! </p>

<p class="definition">Definition at line <a class="el" href="ewah-inl_8h_source.html#l00833">833</a> of file <a class="el" href="ewah-inl_8h_source.html">ewah-inl.h</a>.</p>

</div>
</div>
<a id="a43c66c41653d71a2ced5c0f6fa46b7ad" name="a43c66c41653d71a2ced5c0f6fa46b7ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43c66c41653d71a2ced5c0f6fa46b7ad">&#9670;&#160;</a></span>toVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; size_t &gt; <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::toVector </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a vector containing the position of the set bits in increasing order. </p>
<p>This just calls "toArray". </p>

<p class="definition">Definition at line <a class="el" href="ewah_8h_source.html#l00562">562</a> of file <a class="el" href="ewah_8h_source.html">ewah.h</a>.</p>

</div>
</div>
<a id="ae2e27b9636665da8a1db214d30bb0b23" name="ae2e27b9636665da8a1db214d30bb0b23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2e27b9636665da8a1db214d30bb0b23">&#9670;&#160;</a></span>trim()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::trim </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recover wasted memory usage. </p>
<p>Fit buffers to the actual data. </p>

<p class="definition">Definition at line <a class="el" href="ewah_8h_source.html#l00048">48</a> of file <a class="el" href="ewah_8h_source.html">ewah.h</a>.</p>

</div>
</div>
<a id="aff6e5f23f9bd6dd826de4295fd92dcd4" name="aff6e5f23f9bd6dd826de4295fd92dcd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff6e5f23f9bd6dd826de4295fd92dcd4">&#9670;&#160;</a></span>uncompress()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classewah_1_1_e_w_a_h_bool_array_iterator.html">EWAHBoolArrayIterator</a>&lt; uword &gt; <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::uncompress </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterate over the uncompressed words. </p>
<p>Can be considerably faster than <a class="el" href="#a7fb78ae6e98b0668facae5b40387a6ce" title="Returns an iterator that can be used to access the position of the set bits.">begin()</a>/end(). Running time complexity of a full scan is proportional to the uncompressed size of the bitmap. </p>

<p class="definition">Definition at line <a class="el" href="ewah-inl_8h_source.html#l00710">710</a> of file <a class="el" href="ewah-inl_8h_source.html">ewah-inl.h</a>.</p>

</div>
</div>
<a id="a2544580dbbf767740398205138b331b0" name="a2544580dbbf767740398205138b331b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2544580dbbf767740398205138b331b0">&#9670;&#160;</a></span>write() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::write </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>capacity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>savesizeinbits</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>same as write(std::ostream...), except that you provide a char pointer and a "capacity" (in bytes). </p>
<p>The function never writes at or beyond "out+capacity". If the storage needed exceeds the given capacity, the value zero is returned: it should be considered an error. Otherwise, the number of bytes copied is returned. </p>

<p class="definition">Definition at line <a class="el" href="ewah-inl_8h_source.html#l00525">525</a> of file <a class="el" href="ewah-inl_8h_source.html">ewah-inl.h</a>.</p>

</div>
</div>
<a id="ab230c3b69a4ab6d45ab324e60d34600e" name="ab230c3b69a4ab6d45ab324e60d34600e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab230c3b69a4ab6d45ab324e60d34600e">&#9670;&#160;</a></span>write() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>savesizeinbits</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save this bitmap to a stream. </p>
<p>The file format is | sizeinbits | buffer lenth | buffer content| the sizeinbits part can be omitted if "savesizeinbits=false". Both sizeinbits and buffer length are saved using the uint64_t data type. Returns how many bytes were handed out to the stream. </p>

<p class="definition">Definition at line <a class="el" href="ewah-inl_8h_source.html#l00503">503</a> of file <a class="el" href="ewah-inl_8h_source.html">ewah-inl.h</a>.</p>

</div>
</div>
<a id="aabae9f0dcc0048b70ff4e9e397bacf4c" name="aabae9f0dcc0048b70ff4e9e397bacf4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabae9f0dcc0048b70ff4e9e397bacf4c">&#9670;&#160;</a></span>writeBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class uword &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">ewah::EWAHBoolArray</a>&lt; uword &gt;::writeBuffer </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This only writes the content of the buffer (see <a class="el" href="#ab230c3b69a4ab6d45ab324e60d34600e" title="Save this bitmap to a stream.">write()</a>) method. </p>
<p>It is for advanced users. </p>

<p class="definition">Definition at line <a class="el" href="ewah-inl_8h_source.html#l00488">488</a> of file <a class="el" href="ewah-inl_8h_source.html">ewah-inl.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/ewah/<a class="el" href="ewah_8h_source.html">ewah.h</a></li>
<li>include/ewah/<a class="el" href="runninglengthword_8h_source.html">runninglengthword.h</a></li>
<li>include/ewah/<a class="el" href="ewah-inl_8h_source.html">ewah-inl.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>ewah</b></li><li class="navelem"><a class="el" href="classewah_1_1_e_w_a_h_bool_array.html">EWAHBoolArray</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
